# Phase 3: DM ìºì‹±, í”„ë¡œí•„ ìºì‹±, ì„±ëŠ¥ ìµœì í™” ê³„íš

## ëª©í‘œ

ê¸°ì¡´ ê²Œì‹œê¸€/ëŒ“ê¸€ ìºì‹±ì— ì´ì–´ DMê³¼ í”„ë¡œí•„ ìºì‹±ì„ ì¶”ê°€í•˜ê³ , ì „ì²´ ìºì‹œ ì‹œìŠ¤í…œì˜ ì„±ëŠ¥ì„ ìµœì í™”í•©ë‹ˆë‹¤.

---

## 1. DM ìºì‹± êµ¬í˜„

### 1.1 í˜„ì¬ ìƒíƒœ ë¶„ì„

**ê¸°ì¡´ êµ¬í˜„** ([lib/services/dm_service.dart](lib/services/dm_service.dart)):
```dart
// ë©”ëª¨ë¦¬ ìºì‹œë§Œ ì¡´ì¬ (TTL ì—†ìŒ)
final Map<String, Conversation> _conversationCache = {};
final Map<String, List<DMMessage>> _messageCache = {};
```

**ë¬¸ì œì :**
- ë©”ëª¨ë¦¬ ì „ìš© (ì•± ì¢…ë£Œ ì‹œ ì†ì‹¤)
- TTL ì—†ìŒ (ë¬´ì œí•œ ë©”ëª¨ë¦¬ ì‚¬ìš©)
- ë””ìŠ¤í¬ ìºì‹œ ì—†ìŒ (ì˜¤í”„ë¼ì¸ ë¶ˆê°€)
- ë¬´íš¨í™” ë¡œì§ ì—†ìŒ

### 1.2 êµ¬í˜„ ê³„íš

#### 1.2.1 ëª¨ë¸ì— toMap/fromMap ì¶”ê°€

**íŒŒì¼:** [lib/models/conversation.dart](lib/models/conversation.dart)

```dart
// ìºì‹±ìš© Map ë³€í™˜ ë©”ì„œë“œ ì¶”ê°€
Map<String, dynamic> toMap() {
  return {
    'id': id,
    'participants': participants,
    'participantNames': participantNames,
    'participantPhotos': participantPhotos,
    'isAnonymous': isAnonymous,
    'lastMessage': lastMessage,
    'lastMessageTime': lastMessageTime.millisecondsSinceEpoch,
    'lastMessageSenderId': lastMessageSenderId,
    'unreadCount': unreadCount,
    'postId': postId,
    'dmTitle': dmTitle,
    'createdAt': createdAt.millisecondsSinceEpoch,
    'updatedAt': updatedAt.millisecondsSinceEpoch,
    'archivedBy': archivedBy,
    'userLeftAt': userLeftAt.map((k, v) => MapEntry(k, v?.millisecondsSinceEpoch)),
    'rejoinedAt': rejoinedAt.map((k, v) => MapEntry(k, v?.millisecondsSinceEpoch)),
  };
}

factory Conversation.fromMap(Map<String, dynamic> map, String id) {
  // fromFirestoreì™€ ìœ ì‚¬í•˜ì§€ë§Œ millisecondsSinceEpoch ì‚¬ìš©
}
```

**íŒŒì¼:** [lib/models/dm_message.dart](lib/models/dm_message.dart)

```dart
Map<String, dynamic> toMap() {
  return {
    'id': id,
    'senderId': senderId,
    'text': text,
    'createdAt': createdAt.millisecondsSinceEpoch,
    'isRead': isRead,
    'readAt': readAt?.millisecondsSinceEpoch,
  };
}

factory DMMessage.fromMap(Map<String, dynamic> map, String id) {
  return DMMessage(
    id: id,
    senderId: map['senderId'] ?? '',
    text: map['text'] ?? '',
    createdAt: DateTime.fromMillisecondsSinceEpoch(map['createdAt']),
    isRead: map['isRead'] ?? false,
    readAt: map['readAt'] != null 
        ? DateTime.fromMillisecondsSinceEpoch(map['readAt']) 
        : null,
  );
}
```

#### 1.2.2 Hive ëª¨ë¸ ìƒì„±

**íŒŒì¼:** `lib/models/cache/cached_conversation.dart` (ì‹ ê·œ)

```dart
import 'package:hive/hive.dart';
import '../conversation.dart';

part 'cached_conversation.g.dart';

@HiveType(typeId: 2)
class CachedConversation extends HiveObject {
  @HiveField(0)
  final String id;
  
  @HiveField(1)
  final Map<String, dynamic> data;
  
  @HiveField(2)
  final DateTime cachedAt;
  
  CachedConversation({
    required this.id,
    required this.data,
    required this.cachedAt,
  });
  
  Conversation toConversation() => Conversation.fromMap(data, id);
  
  factory CachedConversation.fromConversation(Conversation conv) {
    return CachedConversation(
      id: conv.id,
      data: conv.toMap(),
      cachedAt: DateTime.now(),
    );
  }
}
```

**íŒŒì¼:** `lib/models/cache/cached_dm_message.dart` (ì‹ ê·œ)

```dart
import 'package:hive/hive.dart';
import '../dm_message.dart';

part 'cached_dm_message.g.dart';

@HiveType(typeId: 3)
class CachedDMMessage extends HiveObject {
  @HiveField(0)
  final String id;
  
  @HiveField(1)
  final Map<String, dynamic> data;
  
  @HiveField(2)
  final DateTime cachedAt;
  
  CachedDMMessage({
    required this.id,
    required this.data,
    required this.cachedAt,
  });
  
  DMMessage toMessage() => DMMessage.fromMap(data, id);
  
  factory CachedDMMessage.fromMessage(DMMessage msg) {
    return CachedDMMessage(
      id: msg.id,
      data: msg.toMap(),
      cachedAt: DateTime.now(),
    );
  }
}
```

#### 1.2.3 DM ìºì‹œ ë§¤ë‹ˆì €

**íŒŒì¼:** `lib/services/cache/dm_cache_manager.dart` (ì‹ ê·œ)

```dart
import 'package:hive/hive.dart';
import 'base_cache_manager.dart';
import 'cache_policy.dart';
import 'cache_feature_flags.dart';
import '../../models/conversation.dart';
import '../../models/dm_message.dart';
import '../../models/cache/cached_conversation.dart';
import '../../models/cache/cached_dm_message.dart';
import '../../utils/logger.dart';

class DMCacheManager extends BaseCacheManager<CachedConversation> {
  static final DMCacheManager _instance = DMCacheManager._internal();
  factory DMCacheManager() => _instance;
  DMCacheManager._internal();
  
  @override
  Box<CachedConversation>? get box {
    try {
      return Hive.isBoxOpen('conversations') 
          ? Hive.box<CachedConversation>('conversations') 
          : null;
    } catch (e) {
      return null;
    }
  }
  
  Box<CachedDMMessage>? get messageBox {
    try {
      return Hive.isBoxOpen('dm_messages') 
          ? Hive.box<CachedDMMessage>('dm_messages') 
          : null;
    } catch (e) {
      return null;
    }
  }
  
  @override
  CachePolicy get policy => CachePolicy.dm;
  
  @override
  bool _isDiskExpired(CachedConversation value) {
    return DateTime.now().difference(value.cachedAt) > policy.ttl;
  }
  
  /// ëŒ€í™” ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
  Future<List<Conversation>> getConversations() async {
    if (!CacheFeatureFlags.isDMCacheEnabled) return [];
    
    try {
      final cacheKey = 'conversation_list';
      final cached = await get(cacheKey);
      
      if (cached != null) {
        final conversations = (cached.data['conversations'] as List)
          .map((data) => Conversation.fromMap(data, data['id']))
          .toList();
        Logger.log('ğŸ“¦ ëŒ€í™” ëª©ë¡ ìºì‹œ íˆíŠ¸: ${conversations.length}ê°œ');
        return conversations;
      }
    } catch (e) {
      Logger.error('ëŒ€í™” ëª©ë¡ ìºì‹œ ì½ê¸° ì‹¤íŒ¨: $e');
    }
    
    return [];
  }
  
  /// ëŒ€í™” ëª©ë¡ ì €ì¥
  Future<void> saveConversations(List<Conversation> conversations) async {
    if (!CacheFeatureFlags.isDMCacheEnabled) return;
    
    try {
      final cacheKey = 'conversation_list';
      await put(cacheKey, CachedConversation(
        id: cacheKey,
        data: {
          'conversations': conversations.map((c) => c.toMap()).toList(),
        },
        cachedAt: DateTime.now(),
      ));
      Logger.log('ğŸ’¾ ëŒ€í™” ëª©ë¡ ìºì‹œ ì €ì¥: ${conversations.length}ê°œ');
    } catch (e) {
      Logger.error('ëŒ€í™” ëª©ë¡ ìºì‹œ ì €ì¥ ì‹¤íŒ¨ (ë¬´ì‹œ): $e');
    }
  }
  
  /// íŠ¹ì • ëŒ€í™”ë°©ì˜ ë©”ì‹œì§€ ê°€ì ¸ì˜¤ê¸°
  Future<List<DMMessage>> getMessages(String conversationId) async {
    if (!CacheFeatureFlags.isDMCacheEnabled) return [];
    
    try {
      final msgBox = messageBox;
      if (msgBox == null || !msgBox.isOpen) return [];
      
      final cacheKey = 'messages_$conversationId';
      final cached = msgBox.get(cacheKey);
      
      if (cached != null && !_isMessageExpired(cached)) {
        final messages = (cached.data['messages'] as List)
          .map((data) => DMMessage.fromMap(data, data['id']))
          .toList();
        Logger.log('ğŸ“¦ ë©”ì‹œì§€ ìºì‹œ íˆíŠ¸: ${messages.length}ê°œ (ëŒ€í™”ë°©: $conversationId)');
        return messages;
      }
    } catch (e) {
      Logger.error('ë©”ì‹œì§€ ìºì‹œ ì½ê¸° ì‹¤íŒ¨: $e');
    }
    
    return [];
  }
  
  /// íŠ¹ì • ëŒ€í™”ë°©ì˜ ë©”ì‹œì§€ ì €ì¥
  Future<void> saveMessages(String conversationId, List<DMMessage> messages) async {
    if (!CacheFeatureFlags.isDMCacheEnabled) return;
    
    try {
      final msgBox = messageBox;
      if (msgBox == null || !msgBox.isOpen) return;
      
      final cacheKey = 'messages_$conversationId';
      await msgBox.put(cacheKey, CachedDMMessage(
        id: cacheKey,
        data: {
          'messages': messages.map((m) => m.toMap()).toList(),
        },
        cachedAt: DateTime.now(),
      ));
      Logger.log('ğŸ’¾ ë©”ì‹œì§€ ìºì‹œ ì €ì¥: ${messages.length}ê°œ (ëŒ€í™”ë°©: $conversationId)');
    } catch (e) {
      Logger.error('ë©”ì‹œì§€ ìºì‹œ ì €ì¥ ì‹¤íŒ¨ (ë¬´ì‹œ): $e');
    }
  }
  
  bool _isMessageExpired(CachedDMMessage value) {
    return DateTime.now().difference(value.cachedAt) > policy.ttl;
  }
  
  /// íŠ¹ì • ëŒ€í™”ë°© ìºì‹œ ë¬´íš¨í™”
  void invalidateConversation(String conversationId) {
    if (!CacheFeatureFlags.isDMCacheEnabled) return;
    
    try {
      // ëŒ€í™” ëª©ë¡ ìºì‹œ ë¬´íš¨í™”
      invalidate(key: 'conversation_list');
      
      // ë©”ì‹œì§€ ìºì‹œ ë¬´íš¨í™”
      final msgBox = messageBox;
      if (msgBox != null && msgBox.isOpen) {
        msgBox.delete('messages_$conversationId');
      }
      
      Logger.log('ğŸ’¾ DM ìºì‹œ ë¬´íš¨í™” (ëŒ€í™”ë°©: $conversationId)');
    } catch (e) {
      Logger.error('DM ìºì‹œ ë¬´íš¨í™” ì‹¤íŒ¨ (ë¬´ì‹œ): $e');
    }
  }
}
```

#### 1.2.4 DMService í†µí•©

**íŒŒì¼:** [lib/services/dm_service.dart](lib/services/dm_service.dart) ìˆ˜ì •

```dart
// 1. import ì¶”ê°€
import 'dart:async';
import 'cache/dm_cache_manager.dart';
import 'cache/cache_feature_flags.dart';

// 2. ìºì‹œ ë§¤ë‹ˆì € ì¶”ê°€
class DMService {
  final DMCacheManager _cache = DMCacheManager();
  
  // ê¸°ì¡´ ë©”ëª¨ë¦¬ ìºì‹œëŠ” ì œê±°í•˜ê³  DMCacheManager ì‚¬ìš©
  // final Map<String, Conversation> _conversationCache = {}; // ì œê±°
  // final Map<String, List<DMMessage>> _messageCache = {}; // ì œê±°
  
  // 3. ìºì‹œëœ ëŒ€í™” ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ë©”ì„œë“œ ì¶”ê°€
  Future<List<Conversation>> getCachedConversations() async {
    if (!CacheFeatureFlags.isDMCacheEnabled) return [];
    
    try {
      return await _cache.getConversations();
    } catch (e) {
      Logger.error('ìºì‹œëœ ëŒ€í™” ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: $e');
      return [];
    }
  }
  
  // 4. Streamì—ì„œ ìºì‹œ ì—…ë°ì´íŠ¸
  Stream<List<Conversation>> getConversationsStream() {
    // ê¸°ì¡´ Stream ë¡œì§ì— ìºì‹œ ì—…ë°ì´íŠ¸ ì¶”ê°€
    return _firestore
        .collection('conversations')
        .where(...)
        .snapshots()
        .asyncMap((snapshot) async {
          final conversations = ...;
          
          // ìºì‹œ ì—…ë°ì´íŠ¸
          if (CacheFeatureFlags.isDMCacheEnabled) {
            unawaited(_cache.saveConversations(conversations));
          }
          
          return conversations;
        });
  }
  
  // 5. ë©”ì‹œì§€ ì „ì†¡ ì‹œ ìºì‹œ ë¬´íš¨í™”
  Future<bool> sendMessage(...) async {
    final success = await _sendToFirestore(...);
    
    if (success && CacheFeatureFlags.isDMCacheEnabled) {
      _cache.invalidateConversation(conversationId);
    }
    
    return success;
  }
}
```

#### 1.2.5 CacheManager ì—…ë°ì´íŠ¸

**íŒŒì¼:** [lib/services/cache/cache_manager.dart](lib/services/cache/cache_manager.dart) ìˆ˜ì •

```dart
// 1. import ì¶”ê°€
import '../../models/cache/cached_conversation.dart';
import '../../models/cache/cached_dm_message.dart';

// 2. ì–´ëŒ‘í„° ë“±ë¡
Hive.registerAdapter(CachedConversationAdapter());
Hive.registerAdapter(CachedDMMessageAdapter());

// 3. ë°•ìŠ¤ ì—´ê¸°
await Hive.openBox<CachedConversation>('conversations');
await Hive.openBox<CachedDMMessage>('dm_messages');

// 4. ì‚­ì œ ë©”ì„œë“œì— ì¶”ê°€
await Hive.deleteBoxFromDisk('conversations');
await Hive.deleteBoxFromDisk('dm_messages');
```

---

## 2. í”„ë¡œí•„ ìºì‹± êµ¬í˜„

### 2.1 í˜„ì¬ ìƒíƒœ ë¶„ì„

**ëª¨ë¸:** [lib/models/user_profile.dart](lib/models/user_profile.dart)
- `toFirestore()` ìˆìŒ (Timestamp ì‚¬ìš©)
- `fromFirestore()` ìˆìŒ
- ìºì‹±ìš© `toMap()`/`fromMap()` í•„ìš”

**ë¬¸ì œì :**
- í”„ë¡œí•„ ì¡°íšŒ ì‹œ ë§¤ë²ˆ Firestore ì¿¼ë¦¬
- ì¹œêµ¬ ëª©ë¡ ì¡°íšŒ ì‹œ ë°˜ë³µì ì¸ í”„ë¡œí•„ ì¿¼ë¦¬
- ìºì‹± ì—†ìŒ

### 2.2 êµ¬í˜„ ê³„íš

#### 2.2.1 ëª¨ë¸ì— toMap/fromMap ì¶”ê°€

**íŒŒì¼:** [lib/models/user_profile.dart](lib/models/user_profile.dart)

```dart
// ìºì‹±ìš© Map ë³€í™˜ ë©”ì„œë“œ ì¶”ê°€
Map<String, dynamic> toMap() {
  return {
    'uid': uid,
    'displayName': displayName,
    'photoURL': photoURL,
    'nickname': nickname,
    'nationality': nationality,
    'email': email,
    'university': university,
    'friendsCount': friendsCount,
    'incomingCount': incomingCount,
    'outgoingCount': outgoingCount,
    'createdAt': createdAt.millisecondsSinceEpoch,
    'updatedAt': updatedAt.millisecondsSinceEpoch,
  };
}

factory UserProfile.fromMap(Map<String, dynamic> map) {
  return UserProfile(
    uid: map['uid'] ?? '',
    displayName: map['displayName'] ?? '',
    photoURL: map['photoURL'],
    nickname: map['nickname'],
    nationality: map['nationality'],
    email: map['email'],
    university: map['university'],
    friendsCount: map['friendsCount'] ?? 0,
    incomingCount: map['incomingCount'] ?? 0,
    outgoingCount: map['outgoingCount'] ?? 0,
    createdAt: DateTime.fromMillisecondsSinceEpoch(map['createdAt']),
    updatedAt: DateTime.fromMillisecondsSinceEpoch(map['updatedAt']),
  );
}
```

#### 2.2.2 Hive ëª¨ë¸ ìƒì„±

**íŒŒì¼:** `lib/models/cache/cached_user_profile.dart` (ì‹ ê·œ)

```dart
import 'package:hive/hive.dart';
import '../user_profile.dart';

part 'cached_user_profile.g.dart';

@HiveType(typeId: 4)
class CachedUserProfile extends HiveObject {
  @HiveField(0)
  final String uid;
  
  @HiveField(1)
  final Map<String, dynamic> data;
  
  @HiveField(2)
  final DateTime cachedAt;
  
  CachedUserProfile({
    required this.uid,
    required this.data,
    required this.cachedAt,
  });
  
  UserProfile toProfile() => UserProfile.fromMap(data);
  
  factory CachedUserProfile.fromProfile(UserProfile profile) {
    return CachedUserProfile(
      uid: profile.uid,
      data: profile.toMap(),
      cachedAt: DateTime.now(),
    );
  }
}
```

#### 2.2.3 í”„ë¡œí•„ ìºì‹œ ë§¤ë‹ˆì €

**íŒŒì¼:** `lib/services/cache/profile_cache_manager.dart` (ì‹ ê·œ)

```dart
import 'package:hive/hive.dart';
import 'base_cache_manager.dart';
import 'cache_policy.dart';
import 'cache_feature_flags.dart';
import '../../models/user_profile.dart';
import '../../models/cache/cached_user_profile.dart';
import '../../utils/logger.dart';

class ProfileCacheManager extends BaseCacheManager<CachedUserProfile> {
  static final ProfileCacheManager _instance = ProfileCacheManager._internal();
  factory ProfileCacheManager() => _instance;
  ProfileCacheManager._internal();
  
  @override
  Box<CachedUserProfile>? get box {
    try {
      return Hive.isBoxOpen('profiles') 
          ? Hive.box<CachedUserProfile>('profiles') 
          : null;
    } catch (e) {
      return null;
    }
  }
  
  @override
  CachePolicy get policy => CachePolicy.profile;
  
  @override
  bool _isDiskExpired(CachedUserProfile value) {
    return DateTime.now().difference(value.cachedAt) > policy.ttl;
  }
  
  /// í”„ë¡œí•„ ê°€ì ¸ì˜¤ê¸°
  Future<UserProfile?> getProfile(String uid) async {
    if (!CacheFeatureFlags.isProfileCacheEnabled) return null;
    
    try {
      final cached = await get(uid);
      if (cached != null) {
        Logger.log('ğŸ“¦ í”„ë¡œí•„ ìºì‹œ íˆíŠ¸: $uid');
        return cached.toProfile();
      }
    } catch (e) {
      Logger.error('í”„ë¡œí•„ ìºì‹œ ì½ê¸° ì‹¤íŒ¨: $e');
    }
    
    return null;
  }
  
  /// í”„ë¡œí•„ ì €ì¥
  Future<void> saveProfile(UserProfile profile) async {
    if (!CacheFeatureFlags.isProfileCacheEnabled) return;
    
    try {
      await put(profile.uid, CachedUserProfile.fromProfile(profile));
      Logger.log('ğŸ’¾ í”„ë¡œí•„ ìºì‹œ ì €ì¥: ${profile.uid}');
    } catch (e) {
      Logger.error('í”„ë¡œí•„ ìºì‹œ ì €ì¥ ì‹¤íŒ¨ (ë¬´ì‹œ): $e');
    }
  }
  
  /// ì—¬ëŸ¬ í”„ë¡œí•„ í•œë²ˆì— ì €ì¥
  Future<void> saveProfiles(List<UserProfile> profiles) async {
    if (!CacheFeatureFlags.isProfileCacheEnabled) return;
    
    try {
      for (final profile in profiles) {
        await put(profile.uid, CachedUserProfile.fromProfile(profile));
      }
      Logger.log('ğŸ’¾ í”„ë¡œí•„ ìºì‹œ ì¼ê´„ ì €ì¥: ${profiles.length}ê°œ');
    } catch (e) {
      Logger.error('í”„ë¡œí•„ ìºì‹œ ì¼ê´„ ì €ì¥ ì‹¤íŒ¨ (ë¬´ì‹œ): $e');
    }
  }
}
```

#### 2.2.4 ì‚¬ìš© ì˜ˆì‹œ

í”„ë¡œí•„ì„ ì¡°íšŒí•˜ëŠ” ëª¨ë“  ê³³ì—ì„œ ìºì‹œë¥¼ ë¨¼ì € í™•ì¸:

```dart
// ì˜ˆ: ì¹œêµ¬ ëª©ë¡ ì¡°íšŒ ì‹œ
Future<UserProfile?> getUserProfile(String uid) async {
  // 1. ìºì‹œ í™•ì¸
  final cached = await _profileCache.getProfile(uid);
  if (cached != null) return cached;
  
  // 2. Firestore ì¡°íšŒ
  final doc = await _firestore.collection('users').doc(uid).get();
  if (!doc.exists) return null;
  
  final profile = UserProfile.fromFirestore(doc);
  
  // 3. ìºì‹œ ì €ì¥
  await _profileCache.saveProfile(profile);
  
  return profile;
}
```

---

## 3. ì„±ëŠ¥ ìµœì í™”

### 3.1 ìºì‹œ í¬ê¸° ëª¨ë‹ˆí„°ë§

**íŒŒì¼:** `lib/services/cache/cache_monitor.dart` (ì‹ ê·œ)

```dart
import 'package:hive/hive.dart';
import 'cache_manager.dart';
import '../../utils/logger.dart';

class CacheMonitor {
  static final CacheMonitor _instance = CacheMonitor._internal();
  factory CacheMonitor() => _instance;
  CacheMonitor._internal();
  
  /// ì „ì²´ ìºì‹œ í¬ê¸° í™•ì¸ (MB)
  Future<double> getTotalCacheSize() async {
    try {
      double totalSize = 0;
      
      final boxes = ['metadata', 'posts', 'comments', 'conversations', 'dm_messages', 'profiles'];
      
      for (final boxName in boxes) {
        if (CacheManager.isBoxOpen(boxName)) {
          final box = Hive.box(boxName);
          // ëŒ€ëµì ì¸ í¬ê¸° ê³„ì‚° (ê° í•­ëª©ë‹¹ í‰ê·  í¬ê¸° ì¶”ì •)
          totalSize += box.length * 0.01; // 10KB per item (ì¶”ì •)
        }
      }
      
      return totalSize;
    } catch (e) {
      Logger.error('ìºì‹œ í¬ê¸° ê³„ì‚° ì‹¤íŒ¨: $e');
      return 0;
    }
  }
  
  /// ìºì‹œ í†µê³„
  Map<String, dynamic> getStats() {
    final stats = CacheManager.getStats();
    stats['totalSizeMB'] = getTotalCacheSize();
    return stats;
  }
  
  /// ì˜¤ë˜ëœ ìºì‹œ ì •ë¦¬
  Future<void> cleanOldCache() async {
    try {
      Logger.log('ğŸ§¹ ì˜¤ë˜ëœ ìºì‹œ ì •ë¦¬ ì‹œì‘...');
      
      // ê° ë°•ìŠ¤ì—ì„œ ì˜¤ë˜ëœ í•­ëª© ì‚­ì œ
      // (BaseCacheManagerì˜ TTL ì²´í¬ í™œìš©)
      
      Logger.log('âœ… ì˜¤ë˜ëœ ìºì‹œ ì •ë¦¬ ì™„ë£Œ');
    } catch (e) {
      Logger.error('ìºì‹œ ì •ë¦¬ ì‹¤íŒ¨: $e');
    }
  }
}
```

### 3.2 ë°±ê·¸ë¼ìš´ë“œ ì •ë¦¬ ì‘ì—…

**íŒŒì¼:** [lib/main.dart](lib/main.dart) ìˆ˜ì •

```dart
// ì•± ì‹œì‘ ì‹œ ë°±ê·¸ë¼ìš´ë“œ ì •ë¦¬ ì‘ì—… ì˜ˆì•½
void main() async {
  // ... ê¸°ì¡´ ì´ˆê¸°í™” ì½”ë“œ
  
  // ìºì‹œ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
  await CacheManager.initialize();
  
  // ë°±ê·¸ë¼ìš´ë“œ ì •ë¦¬ ì‘ì—… (5ë¶„ í›„ ì‹¤í–‰)
  Future.delayed(Duration(minutes: 5), () {
    CacheMonitor().cleanOldCache();
  });
  
  runApp(MyApp());
}
```

### 3.3 ë©”ëª¨ë¦¬ ìµœì í™”

**íŒŒì¼:** [lib/services/cache/base_cache_manager.dart](lib/services/cache/base_cache_manager.dart) ê°œì„ 

```dart
// ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§ ì¶”ê°€
int get memoryUsageEstimate {
  // ê° í•­ëª©ë‹¹ ëŒ€ëµì ì¸ í¬ê¸° ê³„ì‚°
  return _memoryCache.length * 1024; // 1KB per item (ì¶”ì •)
}

// ë©”ëª¨ë¦¬ ì••ë°• ì‹œ ê°•ì œ ì •ë¦¬
void forceMemoryCleanup() {
  if (_memoryCache.length > policy.maxMemoryItems ~/ 2) {
    final toRemove = _memoryCache.length - (policy.maxMemoryItems ~/ 2);
    final sortedKeys = _cacheTime.entries
      .toList()
      ..sort((a, b) => a.value.compareTo(b.value));
    
    for (int i = 0; i < toRemove; i++) {
      final key = sortedKeys[i].key;
      _memoryCache.remove(key);
      _cacheTime.remove(key);
    }
    
    Logger.log('ğŸ§¹ ë©”ëª¨ë¦¬ ìºì‹œ ê°•ì œ ì •ë¦¬: $toRemoveê°œ í•­ëª© ì œê±°');
  }
}
```

### 3.4 ë””ìŠ¤í¬ ìºì‹œ ì••ì¶•

**íŒŒì¼:** [lib/services/cache/cache_manager.dart](lib/services/cache/cache_manager.dart) ê°œì„ 

```dart
/// ë””ìŠ¤í¬ ìºì‹œ ì••ì¶• (ì˜¤ë˜ëœ í•­ëª© ì‚­ì œ)
static Future<void> compactCache() async {
  try {
    Logger.log('ğŸ—œï¸ ë””ìŠ¤í¬ ìºì‹œ ì••ì¶• ì‹œì‘...');
    
    final boxes = ['posts', 'comments', 'conversations', 'dm_messages', 'profiles'];
    
    for (final boxName in boxes) {
      if (isBoxOpen(boxName)) {
        final box = Hive.box(boxName);
        await box.compact();
        Logger.log('âœ… $boxName ë°•ìŠ¤ ì••ì¶• ì™„ë£Œ');
      }
    }
    
    Logger.log('âœ… ë””ìŠ¤í¬ ìºì‹œ ì••ì¶• ì™„ë£Œ');
  } catch (e) {
    Logger.error('ë””ìŠ¤í¬ ìºì‹œ ì••ì¶• ì‹¤íŒ¨: $e');
  }
}
```

### 3.5 ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

**íŒŒì¼:** `lib/services/cache/cache_metrics.dart` (ì‹ ê·œ)

```dart
class CacheMetrics {
  static final CacheMetrics _instance = CacheMetrics._internal();
  factory CacheMetrics() => _instance;
  CacheMetrics._internal();
  
  int _cacheHits = 0;
  int _cacheMisses = 0;
  int _networkRequests = 0;
  
  void recordHit() => _cacheHits++;
  void recordMiss() => _cacheMisses++;
  void recordNetworkRequest() => _networkRequests++;
  
  double get hitRate {
    final total = _cacheHits + _cacheMisses;
    return total > 0 ? _cacheHits / total : 0;
  }
  
  Map<String, dynamic> getReport() {
    return {
      'cacheHits': _cacheHits,
      'cacheMisses': _cacheMisses,
      'networkRequests': _networkRequests,
      'hitRate': '${(hitRate * 100).toStringAsFixed(1)}%',
      'networkReduction': '${((1 - networkRequests / (cacheHits + cacheMisses + networkRequests)) * 100).toStringAsFixed(1)}%',
    };
  }
  
  void reset() {
    _cacheHits = 0;
    _cacheMisses = 0;
    _networkRequests = 0;
  }
}
```

---

## 4. êµ¬í˜„ ìˆœì„œ

### Phase 3-1: DM ìºì‹± (1ì£¼)
1. âœ… Conversation/DMMessage ëª¨ë¸ì— toMap/fromMap ì¶”ê°€
2. âœ… CachedConversation/CachedDMMessage Hive ëª¨ë¸ ìƒì„±
3. âœ… ì½”ë“œ ìƒì„± (`flutter packages pub run build_runner build`)
4. âœ… DMCacheManager êµ¬í˜„
5. âœ… CacheManagerì— ì–´ëŒ‘í„°/ë°•ìŠ¤ ë“±ë¡
6. âœ… DMServiceì— ìºì‹œ í†µí•©
7. âœ… í…ŒìŠ¤íŠ¸

### Phase 3-2: í”„ë¡œí•„ ìºì‹± (3ì¼)
1. âœ… UserProfile ëª¨ë¸ì— toMap/fromMap ì¶”ê°€
2. âœ… CachedUserProfile Hive ëª¨ë¸ ìƒì„±
3. âœ… ì½”ë“œ ìƒì„±
4. âœ… ProfileCacheManager êµ¬í˜„
5. âœ… CacheManagerì— ì–´ëŒ‘í„°/ë°•ìŠ¤ ë“±ë¡
6. âœ… í”„ë¡œí•„ ì¡°íšŒí•˜ëŠ” ëª¨ë“  ê³³ì— ìºì‹œ ì ìš©
7. âœ… í…ŒìŠ¤íŠ¸

### Phase 3-3: ì„±ëŠ¥ ìµœì í™” (3ì¼)
1. âœ… CacheMonitor êµ¬í˜„
2. âœ… ë°±ê·¸ë¼ìš´ë“œ ì •ë¦¬ ì‘ì—… ì¶”ê°€
3. âœ… ë©”ëª¨ë¦¬ ìµœì í™”
4. âœ… ë””ìŠ¤í¬ ìºì‹œ ì••ì¶•
5. âœ… CacheMetrics êµ¬í˜„
6. âœ… ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ë° íŠœë‹

---

## 5. ì˜ˆìƒ íš¨ê³¼

### ì„±ëŠ¥ ê°œì„ 
- **DM ë¡œë”©**: 2ì´ˆ â†’ 0.2ì´ˆ (10ë°°)
- **í”„ë¡œí•„ ì¡°íšŒ**: 0.5ì´ˆ â†’ 0.05ì´ˆ (10ë°°)
- **ë„¤íŠ¸ì›Œí¬ ìš”ì²­**: ì „ì²´ 90% ê°ì†Œ
- **ë©”ëª¨ë¦¬ ì‚¬ìš©**: ìµœì í™”ë¡œ 30% ê°ì†Œ

### ì‚¬ìš©ì ê²½í—˜
- ëª¨ë“  í™”ë©´ ì¦‰ì‹œ ë¡œë”©
- ì˜¤í”„ë¼ì¸ì—ì„œë„ ìµœê·¼ ëŒ€í™” í™•ì¸ ê°€ëŠ¥
- ë°ì´í„° ì‚¬ìš©ëŸ‰ ëŒ€í­ ê°ì†Œ
- ë°°í„°ë¦¬ ìˆ˜ëª… ì—°ì¥

### ì €ì¥ ê³µê°„
- DM 500ê°œ: ~300KB
- í”„ë¡œí•„ 100ëª…: ~200KB
- ì´ ìºì‹œ í¬ê¸°: 3-7MB (ë§¤ìš° ì ìŒ)

---

## 6. ì£¼ì˜ì‚¬í•­

### ë°ì´í„° ì¼ê´€ì„±
- DMì€ ì‹¤ì‹œê°„ì„±ì´ ì¤‘ìš”í•˜ë¯€ë¡œ TTLì„ 1ì‹œê°„ìœ¼ë¡œ ì„¤ì •
- ìƒˆ ë©”ì‹œì§€ ìˆ˜ì‹  ì‹œ ì¦‰ì‹œ ìºì‹œ ë¬´íš¨í™”
- ì½ìŒ ìƒíƒœ ë³€ê²½ ì‹œ ìºì‹œ ì—…ë°ì´íŠ¸

### ë©”ëª¨ë¦¬ ê´€ë¦¬
- ë©”ëª¨ë¦¬ ìºì‹œëŠ” ìµœì†Œí•œìœ¼ë¡œ ìœ ì§€
- ë””ìŠ¤í¬ ìºì‹œë¥¼ ì£¼ë¡œ í™œìš©
- ì•± ë°±ê·¸ë¼ìš´ë“œ ì§„ì… ì‹œ ë©”ëª¨ë¦¬ ìºì‹œ ì •ë¦¬

### ë³´ì•ˆ
- ë¯¼ê°í•œ DM ë‚´ìš©ì€ ì•”í˜¸í™” ê³ ë ¤
- ë¡œê·¸ì•„ì›ƒ ì‹œ ëª¨ë“  ìºì‹œ ì‚­ì œ
- í”„ë¡œí•„ ì •ë³´ëŠ” ê³µê°œ ì •ë³´ë§Œ ìºì‹œ

---

## 7. í…ŒìŠ¤íŠ¸ ê³„íš

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
- ê° CacheManagerì˜ CRUD ë™ì‘
- TTL ë§Œë£Œ í™•ì¸
- ë¬´íš¨í™” ë¡œì§

### í†µí•© í…ŒìŠ¤íŠ¸
- ìºì‹œ íˆíŠ¸/ë¯¸ìŠ¤ ì‹œë‚˜ë¦¬ì˜¤
- ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ì‹œ í´ë°±
- ë™ì‹œì„± í…ŒìŠ¤íŠ¸

### ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
- 1000ê°œ ë©”ì‹œì§€ ë¡œë”© ì‹œê°„
- 100ëª… í”„ë¡œí•„ ì¡°íšŒ ì‹œê°„
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¸¡ì •
- ë””ìŠ¤í¬ I/O ì¸¡ì •

---

## 8. ë¡¤ì•„ì›ƒ ì „ëµ

### 1ë‹¨ê³„: ê°œë°œ í™˜ê²½ (1ì£¼)
- Feature Flag: `dm_cache_enabled = false`
- Feature Flag: `profile_cache_enabled = false`
- ë‚´ë¶€ í…ŒìŠ¤íŠ¸

### 2ë‹¨ê³„: ë² íƒ€ í…ŒìŠ¤í„° (1ì£¼)
- Feature Flag: `dm_cache_enabled = true` (10% ì‚¬ìš©ì)
- Feature Flag: `profile_cache_enabled = true` (10% ì‚¬ìš©ì)
- í”¼ë“œë°± ìˆ˜ì§‘

### 3ë‹¨ê³„: ì „ì²´ ë°°í¬ (1ì£¼)
- Feature Flag: 100% í™œì„±í™”
- ëª¨ë‹ˆí„°ë§
- ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

---

## 9. ì™„ë£Œ ê¸°ì¤€

âœ… **DM ìºì‹±**
- ëŒ€í™” ëª©ë¡ ìºì‹œ ë™ì‘
- ë©”ì‹œì§€ ìºì‹œ ë™ì‘
- ìƒˆ ë©”ì‹œì§€ ì‹œ ìºì‹œ ë¬´íš¨í™”
- ì˜¤í”„ë¼ì¸ì—ì„œ ìµœê·¼ ëŒ€í™” í™•ì¸ ê°€ëŠ¥

âœ… **í”„ë¡œí•„ ìºì‹±**
- í”„ë¡œí•„ ì¡°íšŒ ì‹œ ìºì‹œ ìš°ì„ 
- ì¹œêµ¬ ëª©ë¡ ë¡œë”© ì†ë„ 10ë°° í–¥ìƒ
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™”

âœ… **ì„±ëŠ¥ ìµœì í™”**
- ì „ì²´ ìºì‹œ í¬ê¸° < 10MB
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ < 50MB
- ë„¤íŠ¸ì›Œí¬ ìš”ì²­ 90% ê°ì†Œ
- ì•± ì‹œì‘ ì‹œê°„ < 1ì´ˆ

---

ì´ ê³„íšìœ¼ë¡œ **ì™„ì „í•œ ì˜¤í”„ë¼ì¸ ìš°ì„  ì•±**ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤! ğŸš€





